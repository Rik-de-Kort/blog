<html lang="en">
<head>
<meta charset="utf-8">
<title>Rik's Website - Styles of programming</title>
<link rel="stylesheet" href="style.css">
</head>
<body>
<h1>Styles of programming</h1>
<p>
  At work I encounter a lot of programmers who would like to improve their codebases. The debates surrounding this often use terms like "object-oriented" or "functional". A lot of the time, this is missing the forest of the trees a little: there are many things that are much more important than "object-oriented" versus "functional".
  This post is an attempt to articulate the things that matter, and on the way I hope we can maybe shed some light on "object-oriented" versus "functional".
</p>
<h2>What matters most</h2>
<p>
  The most important thing in a program is data.
  Whatever kind of program you have, the only thing a computer can do is take data from a place, transform it, and put it in another (or the same) place.
  Elegant programs are precise, clear instructions about what needs to go where.
  Achieving clarity about what needs to happen in terms of data is the first step in writing better code.
  The second step is expressing what needs to happen in terms of data in code.
  The main goal here is to make it obvious to others reading the code what is happening and how it is happening.
</p>
<p>
  So, how can you take the first step, achieving clarity? One tool here is writing: write explicitly down where data is coming from and what it looks like.
  Then write down explicitly where data needs to go and what it looks like.
  Start technical: don't worry too much about what the data means. Instead, focus on where data comes from, what kind of data it is, and what kind of data needs to be produced (numbers, text, ...), where it needs to go (fileshare, database, ...).
  Talk this sketch of the technical system over with someone and try to make it as simple as possible.
  The simplest picture is getting info from one system and putting in one other system, both in a single/file/table/etc.
  Don't read from a fileshare <em>and</em> a database if you can help it, don't write to two tables if you can write to just one, and try to avoid "multiple ways of saying the same thing".
  This last point already touches on the meaning of the data a little more.
</p>
<p>
  When you have gained some clarity on the technical input and output side of things, you might have more questions.
  Maybe something depends on what the data transform actually is, what the business value of the program is.
  You can think about this a long time, but most often I find that this is best figured out by just starting to program, or reworking what I already have.
  Make sure you can play around with putting in different inputs and observing the outputs.
  I like to have the test inputs and outputs directly in the program code if at all possible, so I can just look at them, but failing that, a file-based approach can also work.
</p>
<p>
  Writing code like this should give you more clarity as to what you're trying to achieve.
  It should push you fairly quickly to see if you missed any data sources, and if you have a mismatch between how the data comes out of the systems, and how you would like to think of the data when you transform it.
  Now that you are writing code, you can start playing around with <em>how</em> you express things.
</p>

<h2>How to write good code</h2>
<p>
  Defining good code is not too difficult.
  You don't have to know about SOLID or Monads to write it.
  Good code is a direct expression of the thing your program needs to do.
  Whether you use long scripts, an object hierarchy, or something else is mostly irrelevant.
  Depending on the problem you might use any of those; what matters is the intent.
</p>
  Now comes a list of tips that should help.
</p>
<p>
  Main advice: make things that are understandable <em>locally</em>.
  Think to yourself: if my colleague looked at only this bit of the code, would they be able to give me feedback on it without knowing anything else about the project? Examine your code and try to find the hidden dependencies, and find a way to take them out.
</p>
<p>
  This is why I don't like writing classes. There is a lot of information hiding in that little <code>self</code> variable. Your method could be changing anything and everything on it.
</p>
<p>
  When you write a function, declare everything that the function needs in the function signature, and return everything that the function has changed from it.
  Don't read from any variables outside the function, and especially don't modify any variables that are used outside the function.
  Your colleague would need to know about the variables outside of the function to understand what was going on.
  Doing this is called <em>referential transparency</em> and allows you to treat functions as a blackbox.
  Once you have understood a function which is referentially transparent, you can rely on it to always behave the same way.
</p>
<p>
  Watch out for multiple transforms!
  Maybe you take your data from the source in one way, then do a transformation, and then just before doing the real work of your program, you transform it again.
  The best way to get good performance out of your code is to do as little of this as possible.
</p>

<p>
  Most programs fall in one of two categories.
  The first is a program that runs start-to-finish. Maybe it runs on a timer, every day or every week. The job of the program is usually to take data from somewhere, maybe multiple places, do something to that data, and write the result out somewhere else. Examples of this are a program to predict which partners are not going to deliver their information on time, or a program that calculates the total carbon footprint of the investment portfolio.
  The second is a program that needs to interact with the world. This interaction can be with a human, or with another system. The job of the program is to provide insight to a user, or to react to changes in the outside world. Examples of this are a program to trade (maybe algorithmically) currencies on an exchange, or an interactive application to understand why some partners are expected to deliver their information late.
</p>
  
</body>
</html>
