<html lang="en">
<head>
<meta charset="utf-8">
<title>Rik's Website - Pulling on Pandas' yarn</title>

<style>
body {
  width: 80%;
  margin-left: auto;
  margin-right: auto;
  font-family: sans-serif;
  color: #222;
}

quote {
  display: block;
  font-family: serif;
  background-color: #eee;
  padding: 1em;
  margin: 1em;
}
</style>
</head>
<body>
<h1>Unravelling Pandas' read_excel function</h1>
<p>
Pandas is a very robust library with a lot of functionality, but it <span style="font-style:italic">is</span> a big ball of OOP. Read on to find me pulling on the bit of yarn that's called <code>read_excel</code>.
</p>
<p>
Upon importing Pandas, to get <code>pandas.read_excel</code> in the namespace, the interpreter goes from <a href="https://github.com/pandas-dev/pandas/blob/231b9fad17475918a94fc922d5bbd452c5b67a2f/pandas/__init__.py#L143"><code>pandas/__init__.py</code></a> to <a href="https://github.com/pandas-dev/pandas/blob/231b9fad17475918a94fc922d5bbd452c5b67a2f/pandas/io/api.py#L11"><code>pandas/io/api.py</code></a> to <a href="https://github.com/pandas-dev/pandas/blob/231b9fad17475918a94fc922d5bbd452c5b67a2f/pandas/io/excel/__init__.py#L4"><code>pandas/io/excel/__init__.py</code></a> to <code>pandas/io/excel/_base.py</code></a>. That's opening 4 layers of indirection already. This is not the biggest amount of overhead, and everything is easy to find, but it gives you a flavour of what's to come.
</p>
<p>
In <code>base.py</code>, you can find the definition of <code>read_excel</code>. After skipping through the overloads (these are read by the interpreter on import, but are ignored during the rest of the program) <a href="https://github.com/pandas-dev/pandas/blob/231b9fad17475918a94fc922d5bbd452c5b67a2f/pandas/io/excel/_base.py#L427">on line 427 in _base.py</a>. Stepping into the definition, we find the possibility of opening an ExcelFile in case we hadn't already (I usually don't). Then this functions punts all the work to <code>io.parse</code> inside a <code>try-finally</code>-block to make sure the file gets closed at the end.
</p>
<p>
So, off to <code>io.parse</code> we go! Oh, but <code>io</code> is an object, which was sure to be an <code>ExcelFile</code>. So that means we have to go find <code>ExcelFile.parse</code>. This happens to exist in <a href="https://github.com/pandas-dev/pandas/blob/f4ca4d3d0ea6a907262f8c842c691115b13d4cb7/pandas/io/excel/_base.py#L1633">the same file, on line 1633</a>. Reading this method is somewhat disappointing. It just calls <code>self._reader.parse</code>, so we need to figure out what is in <code>self._reader</code> and go from there.
</p>
<p>
Let's assume we called <code>read_excel</code> with just a filepath, so we get the basic <code>ExcelFile</code>, and moreover that we're using the <code>openpyxl</code> engine. Common sense and some code reading tells us we get the <code>OpenpyxlReader</code> from <a href="https://github.com/pandas-dev/pandas/blob/main/pandas/io/excel/_openpyxl.py#L532">_openpyxl.py</a>. At this point I already forgot which function we're trying to call, but luckily we kept notes!
</p>
<p>
Right, <code>parse</code> it is. And this seems... not defined? In the 99 lines of <code>OpenpyxlReader</code>, there is no <code>def parse</code>. Looking closer, we see that this reader inherits from <code>BaseExcelReader</code>. Which lives back in <a href="https://github.com/pandas-dev/pandas/blob/main/pandas/io/excel/_base.py#L501">_base.py</a>. 
</p>
<p>
Now we're finally at the meat of the method (line 675), which took us 6 hops. As you would expect, there is a decent amount of input validation happening: after all, this is a widely used library and who knows what people are going to throw at it. But you have to do all this work every time you want to read in an Excel sheet, even if you <span style="font-style:italic">know</span> you passed the parameters in correctly. [1]
</p>
<p>
The first bit of meaningful work (as in, actually doing something with the Excel sheet or the data it contains) that is actually happening is not in this method at all. It's a <a href="https://github.com/pandas-dev/pandas/blob/main/pandas/io/excel/_base.py#L738">line 738</a> and gets the sheet by a specified name (or index on line 740). This code is actually defined <a href="https://github.com/pandas-dev/pandas/blob/ed55bdf198590dd572f2e546c7b2afe7ae98ba74/pandas/io/excel/_openpyxl.py#L568">back in the OpenpyxlReader</a>.
</p>
<p>
After this there's a bunch more code that takes care of figuring out what kind of headers and indexes the file has, and what we should do about it. And then, and I really hope you guessed it, because this has been going on all the time in this story, the function punts the remaining work of actually parsing the rest of the data to <code>TextParser</code>, which lives in <a href="https://github.com/pandas-dev/pandas/blob/ed55bdf198590dd572f2e546c7b2afe7ae98ba74/pandas/io/excel/_openpyxl.py#L568">pandas/readers.py</a>. And this function just calls <code>__init__</code> on <code>TextFileReader</code>, so it's a glorified constructor which should live on TextFileReader in the first place. What the calling code <span style="font-style:italic">actually</span> does is call <code>read</code> on said class. [2]
</p>

<p>
And then, finally, once we look at <code>read</code> (<a href="https://github.com/pandas-dev/pandas/blob/ed55bdf198590dd572f2e546c7b2afe7ae98ba74/pandas/io/parsers/readers.py#L1742">Line 1742 in readers.py"</a>), we see the mythical dataframe being created: on line 1775, we find <code>df = DataFrame(col_dict, columns=columns, index=index)</code>. Great!
</p>
<p>
But where does <code>col_dict</code> come from? Glad you asked. From <code>self._engine.read</code> (Line 1758). So after you have burrowed yourself knee deep in the layers and layers of indirection that go into this code, you don't (I certainly don't) even remember where the engine argument was passed in. I know the engine argument we passed in <span style="font-style:italic">somewhere</span> is "openpyxl".
</p>
<p>
But as it turns out, this <code>self._engine.read</code> is <span style="font-style:italic">another</span> type of engine, namely one which parses a bunch of text (the clue is in the name "TextReader"). 
</p>
<p>
You can keep pulling at this yarn, and more stuff will keep coming out, but let's stop there. The point is, this code is very hard to read: there's a lot of hopping around while you're trying to remember what your place in the code was, a lot of back and forth, and a lot of stuff that seems only tangentially related to the task at hand.
</p>
<p>
Part of this lies in the design: Pandas is built using OOP principles, and so it seems natural to have a base class for reading Excel files that handles all the common logic, where the subclasses implement their specific piece of the puzzle. But as you can tell, this terrible for code readability (and thus maintainability). A much cleaner design would be to write a function that does all of this header and text extraction business, and takes in the data already extracted from the Excelsheet and puts it into a neat DataFrame. Extract - Transform - Load. <a href="https://en.wikipedia.org/wiki/Extract,_transform,_load">We've known about this process since the 70s</a>. You can even put it into a nice little function to keep together to maintain API compatibility, something like this:
</p>
<pre><code>
def read_excel(io, engine, sheet_name=None, **kwds):
    # Extract
    data = engine.extract_raw_data(io, sheet_name=sheet_name)  # Doesn't have to be a function!
    # Transform
    index, columns = find_columns_and_index(data, **kwds)
    parsed_data = parse_text(data, **kwds)
    # Load
    return DataFrame(parsed_data, columns=columns, index=index)
</code></pre>

<p>
Another factor is the giant amount of features the Excel reader has, and the fact that <code>read_excel</code> is <span style="font-style:italic">the</span> entrypoint to read Excel-related files, no matter what kind of file you are reading. It has many many options; some of them relating to the extraction step, some of them related to the transformation step, and some of them relating to the load step. One example is passing in <code>storage_options</code> which gets passed on to the ExcelFile constructor and influences how to open it. It allows you to open an Excel file from a url.
</p>
<p>
Yes, you can open Excel files from URLs. And if you pass in <code>storage_options</code> you can even pass in basic authentication like a Bearer token to the <a href="https://github.com/pandas-dev/pandas/blob/231b9fad17475918a94fc922d5bbd452c5b67a2f/pandas/io/common.py#L361">underlying urrlib3 request</a>. I mean, that's a nice feature, but what's wrong with just passing in a BytesIO?
</p>

<pre><code>
import pandas as pd
from io import BytesIO
import requests

response = requests.get('https://github.com/pandas-dev/pandas/blob/main/pandas/tests/io/data/excel/test1.xlsm?raw=true')
response.raise_for_status()
df = pd.read_excel(BytesIO(response.content))
</code></pre>

<p>
With this method, you can also adjust the security settings of your request, the data passed in, unwrapping the response,.... At my current workplace all internal network traffic is unencrypted, and then re-encrypted at the network boundary. That does lead to some SSL-headaches every now and again, and having control over network is a boon there.
</p>
<p>
It's also more flexible: what if the Excel Sheet was in a database instead, say some SQL Server which stores binary blobs of Excel files? With the above pattern, it's obvious: I just pull down the Excelfile like normal, using something like <code>pyodbc</code>, and then pass it in in exactly the same way. What's the alternative? Add yet another option to <code>read_excel</code>? Have <code>read_sql</code> grow the capability of parsing Excel files from database tables?
</p>
<p>
So, uhh, yeah. Big rant, here's the point: Pandas is a big ball of features. A very useful big ball of features, but the features are not very orthogonal: they intersect, interlock, and interdepend. The ways they do so is very hard to anticipate from reading the code. And that makes it pretty difficult to use when you want to do something "different", or adapt the code to your needs.
</p>


<h3>Footnotes</h3>
<ol>
    <li>To be fair, this is really a Python issue, because in statically typed languages you don't need to check types at runtime. I tend to use a lot of asserts.</li>
    <li>If your use for a class is "call <code>__init__</code> and then a method", that's not a class, that's a function.</li>
</ol>
</body>
</html>
